author_notes: ''
blurb: ''
default_skin: snapshots_v1
init_state_name: First State
language_code: en
objective: Work through the Towers of Hanoi problem.
param_changes:
- customization_args:
    parse_with_jinja: true
    value: '3'
  generator_id: Copier
  name: HanoiTower0numDisks
param_specs:
  HanoiTower0numDisks:
    obj_type: UnicodeString
  UserResponseTimeToSolve:
    obj_type: UnicodeString
schema_version: 5
skin_customizations:
  panels_contents:
    main:
    - customization_args: {}
      gadget_id: HanoiTower
      visible_in_states:
      - First State
      - Decomposition
      - Towers - 3 Disks
      - 4 Disk Move Question
      - Reflection on Moves
      - Abstracting the Pattern Part 1
states:
  3 Disk Solution:
    content:
    - type: text
      value: <p><oppia-noninteractive-image filepath-with-value="&amp;quot;3-disk-solution-full.gif&amp;quot;"></oppia-noninteractive-image><br><span></span></p><p><br></p><p>Click
        <b>Next</b> to Continue.</p>
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: 4 Disk Move Question
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  4 Disk Move Question:
    content:
    - type: text
      value: <div><span>Now, let's try solving it with 4 disks. After you have solved
        this version or at least attempted it answer the question below.</span></div><div><span><br></span></div><div><span>Based
        on your previous attempts, what is your estimate of the minimum number of
        moves needed to solve the 4 disk version?</span></div>
    interaction:
      customization_args:
        placeholder:
          value: ''
        rows:
          value: 1
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Moves Pattern Question
          feedback: []
          param_changes: []
      id: TextInput
      triggers: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '4'
      generator_id: Copier
      name: HanoiTower0numDisks
  Abstracting the Pattern 2-1:
    content:
    - type: text
      value: "<div>This is what we see from looking at the pattern of moves.\_</div><ol><li><span>The\
        \ move between Towers A and C is the first move so we can include it as our\
        \ first step.</span></li><li><span>Since the move from Tower A and C is repeated\
        \ in step 4 and 7 we will likely need to repeat all of the instructions over\
        \ and over until the puzzle is solved.</span></li><li>The move between Tower\
        \ A and C is repeated at the 4th move so there must be 2 more steps.</li></ol><p><br></p><p>Using\
        \ this information we can start to build our algorithm.</p><p><i>An algorithm\
        \ for solving the 3 disk tower puzzle</i></p><ol><li><i>Move a disk between\
        \ tower A and tower C</i></li><li><br></li><li><br></li><li><i>Repeat this\
        \ process until the puzzle is solved<br></i></li></ol><p><br></p><p>Click<span>\_\
        </span><b>Next</b><span>\_</span>to continue.</p>"
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Abstracting the Pattern Part 3
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  Abstracting the Pattern Part 1:
    content:
    - type: text
      value: "<div><span>Here is an example list of moves in solving a 3 tower puzzle\
        \ referring only to the towers:\_</span><br></div><ol><li><span>Tower A, Tower\
        \ C\_</span></li><li><span>Tower A, Tower B\_</span></li><li><span>Tower C,\
        \ Tower B</span></li><li><span>Tower A, Tower C\_</span></li><li><span>Tower\
        \ B, Tower A</span></li><li><span>Tower B, Tower C\_</span></li><li><span>Tower\
        \ A, Tower C</span></li></ol><p>Based on this list of moves, at which line\
        \ does the pattern start over again?</p>"
    interaction:
      customization_args:
        placeholder:
          value: Line number
        rows:
          value: 1
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: '4'
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Abstracting the Pattern Part 2
          feedback:
          - <p>Yes, at line 4 we see towers A and C used again.</p>
          param_changes: []
        - definition:
            rule_type: default
          dest: Abstracting the Pattern Part 1
          feedback:
          - <p>Try again. For this pattern A and B is the same as B and A.</p>
          param_changes: []
      id: TextInput
      triggers:
      - customization_args:
          num_submits: 2
        dest: Abstracting the Pattern Part 2
        feedback:
        - <p>At line 4 towers A and C are used again in the list of moves.<br></p>
        name: on_nth_resubmission
        param_changes: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '4'
      generator_id: Copier
      name: HanoiTower0numDisks
  Abstracting the Pattern Part 2:
    content:
    - type: text
      value: "<div>Example moves for 3 tower puzzle</div><ol><li><span><b>Tower A,\
        \ Tower C\_</b></span></li><li><span>Tower A, Tower B\_</span></li><li><span>Tower\
        \ C, Tower B</span></li><li><span><b>Tower A, Tower C\_</b></span></li><li><span>Tower\
        \ B, Tower A</span></li><li><span>Tower B, Tower C\_</span></li><li><span><b>Tower\
        \ A, Tower C</b></span></li></ol><p>We see that a disk is moved between Towers\
        \ A and C in step 4 and again at step 7. From this we can gather three useful\
        \ pieces of information to help us build our <b>algorithm</b>\_or instructions\
        \ for someone trying to solve the puzzle.</p><p><br></p><p>Click <b>Next</b>\
        \ to develop an algorithm based on this information.</p>"
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Abstracting the Pattern 2-1
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  Abstracting the Pattern Part 3:
    content:
    - type: text
      value: "<div>Example moves for 3 tower puzzle</div><ol><li><span><span>Tower\
        \ A, Tower C\_</span></span></li><li><span>Tower A, Tower B\_</span></li><li><span>Tower\
        \ C, Tower B</span></li><li><span><span>Tower A, Tower C\_</span></span></li><li><span>Tower\
        \ B, Tower A</span></li><li><span>Tower B, Tower C\_</span></li><li><span><span>Tower\
        \ A, Tower C</span></span></li></ol><div>Based on the example moves above,\
        \ after Towers A and C are repeated, which Towers come next?<span></span></div>"
    interaction:
      customization_args:
        choices:
          value:
          - <p>Towers A and B</p>
          - <p>Towers A and C</p>
          - <p>Towers B and C</p>
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: 0
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Abstracting the Pattern Part 4
          feedback:
          - '<p>Yes this is the next move we see repeated in the pattern and so let''s
            add it as the second step in the algorithm.

            <br></p>'
          param_changes: []
        - definition:
            inputs:
              x: 1
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Abstracting the Pattern Part 3
          feedback:
          - <p>We already have this step in our algorithm. Look in the example moves
            for the towers that come after this one.</p>
          param_changes: []
        - definition:
            rule_type: default
          dest: Abstracting the Pattern Part 3
          feedback:
          - '<p>Try again. Look at the next towers repeated in the example steps to
            determine what the next move should be in our algorithm.

            For this pattern A and B is the same as B and A.<br></p>'
          param_changes: []
      id: MultipleChoiceInput
      triggers:
      - customization_args:
          num_submits: 2
        dest: Abstracting the Pattern Part 4
        feedback:
        - "<p>Towers A and B is the next move we see repeated in the pattern and so\
          \ let's add it as the second step in the algorithm.\_<br></p>"
        name: on_nth_resubmission
        param_changes: []
    param_changes: []
  Abstracting the Pattern Part 4:
    content:
    - type: text
      value: <div></div><div><span></span></div><div><i>An algorithm for solving the
        3 disk tower puzzle</i><br></div><ol><li><i>Move a disk between tower A and
        tower C</i></li><li><i>Move a disk between tower A and tower B</i></li><li><br></li><li><i>Repeat
        this process until the puzzle is solved</i></li></ol><div><br></div><div>Excellent,
        our algorithm is almost complete! Click <b>Next</b> to continue developing
        the algorithm.<br></div>
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Abstracting the Pattern Part 4-2
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  Abstracting the Pattern Part 4-2:
    content:
    - type: text
      value: "<div><span>Example moves for 3 tower puzzle</span><br></div><ol><li><span><span>Tower\
        \ A, Tower C\_</span></span></li><li><span>Tower A, Tower B\_</span></li><li><span>Tower\
        \ C, Tower B</span></li><li><span><span>Tower A, Tower C\_</span></span></li><li><span>Tower\
        \ B, Tower A</span></li><li><span>Tower B, Tower C\_</span></li><li><span><span>Tower\
        \ A, Tower C</span></span></li></ol><div>Can you figure out the final pattern\
        \ and complete the algorithm? What are the final towers repeated in the example\
        \ steps above?</div>"
    interaction:
      customization_args:
        choices:
          value:
          - <p>Towers A and B</p>
          - <p>Towers A and C</p>
          - <p>Towers B and C</p>
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: 2
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Abstraction Debrief
          feedback:
          - <p>Yes this is the third move we see repeated in the pattern and so let's
            make it the third step in the algorithm.<br></p>
          param_changes: []
        - definition:
            rule_type: default
          dest: Abstracting the Pattern Part 4-2
          feedback:
          - "<p>Try again, look at the example pattern to see what is the next move\
            \ made.\_For this pattern A and B is the same as B and A.<br></p>"
          param_changes: []
      id: MultipleChoiceInput
      triggers:
      - customization_args:
          num_submits: 2
        dest: Abstraction Debrief
        feedback:
        - <p>Towers B and C is the third move we see repeated in the pattern and so
          let's make it the third step in the algorithm.<br></p>
        name: on_nth_resubmission
        param_changes: []
    param_changes: []
  Abstraction Debrief:
    content:
    - type: text
      value: <div>Congratulations, you were able to identify patterns within a solution
        and abstract or generalize it into an algorithm.</div><p><br></p><p><i>An
        algorithm for solving the 3 disk tower puzzle</i></p><ol><li><i>Move a disk
        between tower A and tower C</i></li><li><i>Move a disk between tower A and
        tower B</i></li><li><i>Move a disk between tower B and tower C</i></li><li><i>Repeat
        this process until the puzzle is solved</i></li></ol><p>It turns out that
        these instructions can be used to solve the towers puzzle where the number
        of disks is odd (3, 7, and 13 disks). You may want to try modifying the algorithm
        to have one that works for even numbers. Equipped with this you can solve
        any version of the tower puzzle given enough time.</p><p><br></p><p>Click
        <b>Next</b> to continue.</p>
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Big question
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '4'
      generator_id: Copier
      name: HanoiTower0numDisks
  Big question:
    content:
    - type: text
      value: "<p>Let's\_revisit the original question. If someone is solving a 64-disk\
        \ version of the towers puzzle at a rate of one disk per second, and the world\
        \ is supposed to end when it is solved, should we be worried?</p><p><span><br></span></p><p><span>Originally,\
        \ you thought it would take {{ UserResponseTimeToSolve }} to solve the puzzle.\
        \ Based on the patterns you have found, how long would it take to solve a\
        \ 64 disk version of the towers puzzle?</span></p>"
    interaction:
      customization_args:
        choices:
          value:
          - <p>1 day</p>
          - <p>100 years</p>
          - <p>Billions of years</p>
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: 2
            name: Equals
            rule_type: atomic
            subject: answer
          dest: End or Recursion Choice
          feedback:
          - "<p>Yes, it is incredible how fast the amount of time required grows as\
            \ the number of disks increase. The general rule for the moves required\
            \ for a number of disks is\_<oppia-noninteractive-math raw_latex-with-value=\"\
            &amp;quot;\\\\\\\\2^{n} - 1&amp;quot;\"></oppia-noninteractive-math>.\_\
            <oppia-noninteractive-math raw_latex-with-value=\"&amp;quot;\\\\\\\\2^{64}\
            \ - 1&amp;quot;\"></oppia-noninteractive-math>\_is a really big number\
            \ and at one move per second, it would take longer than any estimated\
            \ age of the universe so I think we will be ok.<br></p>"
          param_changes: []
        - definition:
            rule_type: default
          dest: Big question
          feedback:
          - <p>Thankfully I think we will have more time than that. Why not try again?<br></p>
          param_changes: []
      id: MultipleChoiceInput
      triggers:
      - customization_args:
          num_submits: 2
        dest: End or Recursion Choice
        feedback:
        - "<p>Yes, it is incredible how fast the amount of time required grows as\
          \ the number of disks increase. The general rule for the moves required\
          \ for a number of disks is\_<oppia-noninteractive-math raw_latex-with-value=\"\
          &amp;quot;\\\\\\\\2^{n} - 1&amp;quot;\"></oppia-noninteractive-math>.\_\
          <oppia-noninteractive-math raw_latex-with-value=\"&amp;quot;\\\\\\\\2^{64}\
          \ - 1&amp;quot;\"></oppia-noninteractive-math>\_is a really big number and\
          \ at one move per second, it would take longer than any estimated age of\
          \ the universe so I think we will be ok.<br></p>"
        name: on_nth_resubmission
        param_changes: []
    param_changes: []
  Debrief:
    content:
    - type: text
      value: "<p>If you are interested in learning more about this topic you can search\
        \ for sorting algorithms, recursion, and the towers of hanoi puzzle (its most\
        \ common name).\_</p>"
    interaction:
      customization_args:
        recommendedExplorationIds:
          value: []
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Debrief
          feedback: []
          param_changes: []
      id: EndExploration
      triggers: []
    param_changes: []
  Decomposition:
    content:
    - type: text
      value: "<p><span>All right, let's see if we can figure it out!</span></p><p><br></p><p><span>While\
        \ we could attempt to solve this using the 64 disks mentioned in the original\
        \ problem, it may be simpler to break this problem into a smaller problem\
        \ and see if it is possible to determine the minimum number of moves given\
        \ a number of disks. Otherwise we would only be guessing. In Computational\
        \ Thinking, this is referred to as <b>decomposition</b>.\_</span><br></p><p><br></p><p>Click\
        \ <b>Next </b>to continue.</p><p></p>"
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Towers - 3 Disks
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '3'
      generator_id: Copier
      name: HanoiTower0numDisks
    - customization_args:
        parse_with_jinja: true
        value: answer
      generator_id: Copier
      name: UserResponseTimeToSolve
  End or Recursion Choice:
    content:
    - type: text
      value: "<p>This puzzle is famous not only for its algorithm and the fun people\
        \ have solving the puzzle, but also as an example of recursion. Recursion\
        \ in computer science is a way of describing an algorithm in terms of itself\
        \ so the problem is approached as a series of smaller problems to solve.</p><p><br></p><p>Would\
        \ you like to see how you can create one algorithm for solving the towers\
        \ puzzle using recursion?\_If you are interested in diving in a little deeper\
        \ into the towers puzzle, there is exciting stuff ahead.</p>"
    interaction:
      customization_args:
        choices:
          value:
          - <p>Yes, I'm interested!</p>
          - <p>Not right now.</p>
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: 1
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Debrief
          feedback: []
          param_changes: []
        - definition:
            inputs:
              x: 0
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Recursion Intro
          feedback: []
          param_changes: []
        - definition:
            rule_type: default
          dest: End or Recursion Choice
          feedback: []
          param_changes: []
      id: MultipleChoiceInput
      triggers: []
    param_changes: []
  First State:
    content:
    - type: text
      value: <div></div>There is a legend of a room with 3 posts (towers). On the
        leftmost tower, 64 golden disks are stacked from the biggest disk up to the
        smallest (a simplified version of this is shown on the right). Those entrusted
        with the task of moving all of the disks from one post to another were told
        that the world would end when this task was complete.<div><br></div><div>The
        rules one must follow when solving the tower puzzle are:</div><ol><li><span>Disks
        must be removed one at a time from the top of one tower and placed onto the
        top of another tower.</span></li><li><span>No disk can be larger than any
        disk below it (i.e., the disks on each tower make a pyramid shape).</span></li></ol><span><div><span><br></span></div>If
        there is indeed someone secretly completing this task by moving one disk per
        second, how long do you think it would take them to solve it?</span>
    interaction:
      customization_args:
        unitChoices:
          value:
          - hours
          - days
          - years
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Decomposition
          feedback: []
          param_changes: []
      id: SimpleNumberWithUnitsInput
      triggers: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '3'
      generator_id: Copier
      name: HanoiTower0numDisks
  Moves Pattern Question:
    content:
    - type: text
      value: <p><span>As you were moving those disks back and forth between the towers,
        did you feel like there was a pattern, even if you are unable to articulate
        what that pattern is?</span><br></p>
    interaction:
      customization_args:
        choices:
          value:
          - <p>Yes</p>
          - <p>No</p>
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Reflection on Moves
          feedback: []
          param_changes: []
      id: MultipleChoiceInput
      triggers: []
    param_changes: []
  Recursion Intro:
    content:
    - type: text
      value: "<p>We have a working algorithm for solving the towers puzzle. We will\
        \ apply the process of Computational Thinking a second time in order to develop\
        \ our recursive algorithm.</p><p><br></p><p>Before we dive straight into the\
        \ towers puzzle, let's look at an example of recursion using multiplication.\_\
        We can create a recursive algorithm when considering multiplication as repeated\
        \ addition.</p><p><br></p><p>Click <b>Next</b> to Continue.</p>"
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Recursion Intro Part 2
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  Recursion Intro Part 2:
    content:
    - type: text
      value: "<p><span>Task:\_</span><span>Multiply two numbers a and b</span><br></p><ol><li><span>Rule\
        \ 1: If b equals 1 then answer is a</span></li><li><span>Rule 2: Multiply\
        \ two numbers a and b - 1 and add that result to a.</span></li></ol><div><p></p><p><span>Example:\
        \ Multiply 5 * 4\_</span></p><p></p><ol><li><span>\_ \_ \_ \_ \_ \_ \_ \_\
        \ \_(5 * 3) + 5</span></li><li><span>\_ \_ \_ \_ ((5 * 2) + 5) + 5</span></li><li><span>(((5\
        \ * 1) + 5) + 5 + 5</span></li><li><span>\_ \_ \_ \_ \_ \_ \_5 + 5 + 5 + 5</span></li><li><span>Answer\
        \ is 20</span><br></li></ol><p><br></p><p></p>While this may seem like a more\
        \ complex way of solving a problem, a recursive algorithm can sometimes be\
        \ more succinct. This is true for certain types of algorithms like sorting\
        \ data or generating a series of numbers.</div><p><br></p><p>Click<span>\_\
        </span><b>Next</b><span>\_</span>to see an example of an algorithm to solve\
        \ the towers puzzle using recursion.</p>"
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Recursion Towers
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  Recursion Towers:
    content:
    - type: text
      value: "<p>In our original version of the towers algorithm the steps were repeated\
        \ until the puzzle was finished.\_<span>However there was another more general\
        \ pattern, keep moving the smaller disks onto the other towers until you can\
        \ move the largest disk.</span></p><p><br></p><p>So one recursive explanation\
        \ of how to solve the puzzle is:</p><p><span>Task: Move all the disks from\
        \ tower A to Tower C</span></p><p></p><ol><li><span>Move all disks except\
        \ the last from Tower A to B</span></li><li><span>Move the last disk on Tower\
        \ A to Tower C.</span></li><li><span>Move all of the disks from Tower B to\
        \ Tower C</span></li></ol><span><div><span><br></span></div>If you look closely,\
        \ you'll see that each of these steps will require sub steps where you apply\
        \ the algorithm you created above. Wikipedia's</span><span>\_interactive diagram\
        \ of the </span><oppia-noninteractive-link open_link_in_same_window-with-value=\"\
        false\" text-with-value=\"&amp;quot;towers recursion algorithm&amp;quot;\"\
        \ url-with-value=\"&amp;quot;http://upload.wikimedia.org/wikipedia/commons/2/20/Tower_of_Hanoi_recursion_SMIL.svg&amp;quot;\"\
        ></oppia-noninteractive-link><span>\_may help you to visualize the steps.</span><p><span><br></span></p><p>Click\
        \ <b>Next</b>.</p>"
    interaction:
      customization_args:
        buttonText:
          value: Next
      handlers:
      - name: submit
        rule_specs:
        - definition:
            rule_type: default
          dest: Debrief
          feedback: []
          param_changes: []
      id: Continue
      triggers: []
    param_changes: []
  Reflection on Moves:
    content:
    - type: text
      value: <div><span></span></div><div>The minimum moves required for the:</div><ul><li>3-disk
        version are 7 moves.</li><li>4-disk version are 15 moves.</li></ul><div><span><br></span></div><p>Based
        on these example solutions, how many moves do you think it would take to solve
        a 5-disk version of the Towers puzzle?</p>
    interaction:
      customization_args: {}
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: 31.0
            name: Equals
            rule_type: atomic
            subject: answer
          dest: Abstracting the Pattern Part 1
          feedback:
          - "<p>Yes, the puzzle follows a pattern of\_<oppia-noninteractive-math raw_latex-with-value=\"\
            &amp;quot;\\\\\\\\2^{n} - 1&amp;quot;\"></oppia-noninteractive-math>\_\
            where n is the number of disks. So for a 5-disk puzzle the minimum number\
            \ of moves required would be\_<oppia-noninteractive-math raw_latex-with-value=\"\
            &amp;quot;\\\\\\\\2^{5} -1 = 31&amp;quot;\"></oppia-noninteractive-math><br></p>"
          param_changes: []
        - definition:
            rule_type: default
          dest: Reflection on Moves
          feedback:
          - <div><span>There is a pattern that relates number of disks to moves. You
            can try solving the 5-disk version if it helps you or write down the pattern
            of moves you see.</span><br></div>
          param_changes: []
      id: NumericInput
      triggers:
      - customization_args:
          num_submits: 2
        dest: Abstracting the Pattern Part 1
        feedback:
        - "<p>The puzzle follows a pattern of\_<oppia-noninteractive-math raw_latex-with-value=\"\
          &amp;quot;\\\\\\\\2^{n} - 1&amp;quot;\"></oppia-noninteractive-math>\_where\
          \ n is the number of disks. For a 5 disk puzzle the minimum number of moves\
          \ required would be\_<oppia-noninteractive-math raw_latex-with-value=\"\
          &amp;quot;\\\\\\\\2^{5} -1 = 31&amp;quot;\"></oppia-noninteractive-math>.<br></p>"
        name: on_nth_resubmission
        param_changes: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '5'
      generator_id: Copier
      name: HanoiTower0numDisks
  Towers - 3 Disks:
    content:
    - type: text
      value: "<p><span>In this example of the towers puzzle, there are three disks\
        \ on the left tower. Try to get all of the pieces from that tower to either\
        \ the middle or right tower.</span><br></p><p><br></p><p>Again, here are the\
        \ rules one must follow when solving the tower puzzle:</p><ol><li>disks must\
        \ be removed one at a time from the top of one tower and placed onto the top\
        \ of another tower.\_</li><li>no disk can be larger than any disk below it</li></ol><div><span><br></span></div>If\
        \ you get stuck, you can click the <b>Reset</b> button and try again.<br>"
    interaction:
      customization_args:
        choices:
          value:
          - <p>Show me a possible solution.</p>
          - <p>I'm ready to continue.</p>
      handlers:
      - name: submit
        rule_specs:
        - definition:
            inputs:
              x: 1
            name: Equals
            rule_type: atomic
            subject: answer
          dest: 4 Disk Move Question
          feedback: []
          param_changes: []
        - definition:
            inputs:
              x: 0
            name: Equals
            rule_type: atomic
            subject: answer
          dest: 3 Disk Solution
          feedback: []
          param_changes: []
        - definition:
            rule_type: default
          dest: 4 Disk Move Question
          feedback: []
          param_changes: []
      id: MultipleChoiceInput
      triggers: []
    param_changes:
    - customization_args:
        parse_with_jinja: true
        value: '3'
      generator_id: Copier
      name: HanoiTower0numDisks
tags: []
