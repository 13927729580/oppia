// Copyright 2018 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for SkillEditorStateService.js
 */

// TODO(#7222): Remove the following block of unnnecessary imports once
// skill-editor-state.service.ts is upgraded to Angular 8.
import { AutogeneratedAudioLanguageObjectFactory } from
  'domain/utilities/AutogeneratedAudioLanguageObjectFactory';
import { ChangeObjectFactory } from
  'domain/editor/undo_redo/ChangeObjectFactory';
import { MisconceptionObjectFactory } from
  'domain/skill/MisconceptionObjectFactory';
import { QuestionSummaryObjectFactory } from
  'domain/question/QuestionSummaryObjectFactory';
import { QuestionSummaryForOneSkillObjectFactory } from
  'domain/question/QuestionSummaryForOneSkillObjectFactory';
import { RubricObjectFactory } from
  'domain/skill/RubricObjectFactory';
import { RecordedVoiceoversObjectFactory } from
  'domain/exploration/RecordedVoiceoversObjectFactory';
import { SkillObjectFactory } from 
  'domain/skill/SkillObjectFactory.ts'
import { SkillRightsObjectFactory } from
  'domain/skill/SkillRightsObjectFactory';
import { SubtitledHtmlObjectFactory } from
  'domain/exploration/SubtitledHtmlObjectFactory';
import { VoiceoverObjectFactory } from
  'domain/exploration/VoiceoverObjectFactory';
import { UpgradedServices } from 'services/UpgradedServices';
import { TestBed } from '@angular/core/testing';
// ^^^ This block is to be removed.

require('domain/skill/skill-update.service.ts');
require('pages/skill-editor-page/services/skill-editor-state.service.ts');

fdescribe('Skill editor state service', function() {
  var skillEditorStateService = null, $q, $rootScope,
    skillObjectFactory = null, skillUpdateService = null,
    skillRightsObjectFactory = null;
  var fakeEditableSkillBackendApiService = null;
  var fakeSkillRightsBackendApiService = null;
  var skillRightsObject = null;
  var skillDifficulties = null;

  var FakeEditableSkillBackendApiService = function() {
    var self = {
      newBackendSkillObject: null,
      failure: null,
      fetchSkill: null,
      updateSkill: null
    };

    var _fetchSkill = function() {
      return $q(function(resolve, reject) {
        if (!self.failure) {
          resolve({
            skill: self.newBackendSkillObject,
            groupedSkillSummaries: {
              Name: [{
                id: 'skill_id_1',
                description: 'Description 1'
              }, {
                id: 'skill_id_2',
                description: 'Description 2'
              }]
            }
          });
        } else {
          reject();
        }
      });
    };

    var _updateSkill = function() {
      return $q(function(resolve, reject) {
        if (!self.failure) {
          resolve(self.newBackendSkillObject);
        } else {
          reject();
        }
      });
    };

    self.newBackendSkillObject = {};
    self.failure = null;
    self.fetchSkill = _fetchSkill;
    self.updateSkill = _updateSkill;

    return self;
  };

  var FakeSkillRightsBackendApiService = function() {
    var self = {
      backendSkillRightsObject: null,
      failure: null,
      fetchSkillRights: null
    };

    var _fetchSkillRights = function() {
      return $q(function(resolve, reject) {
        if (!self.failure) {
          resolve(self.backendSkillRightsObject);
        } else {
          reject();
        }
      });
    };

    self.backendSkillRightsObject = {};
    self.failure = null;
    self.fetchSkillRights = _fetchSkillRights;

    return self;
  };

  beforeEach(angular.mock.module('oppia'));
  beforeEach(angular.mock.module('oppia', function($provide) {
    fakeEditableSkillBackendApiService = (
      FakeEditableSkillBackendApiService());
    $provide.value(
      'AutogeneratedAudioLanguageObjectFactory',
      new AutogeneratedAudioLanguageObjectFactory());
    $provide.value('ChangeObjectFactory', new ChangeObjectFactory());
    $provide.value(
      'MisconceptionObjectFactory', new MisconceptionObjectFactory());
    $provide.value('RubricObjectFactory', new RubricObjectFactory());
    $provide.value(
      'QuestionSummaryObjectFactory', new QuestionSummaryObjectFactory());
    $provide.value(
      'QuestionSummaryForOneSkillObjectFactory',
      new QuestionSummaryForOneSkillObjectFactory(
        new QuestionSummaryObjectFactory));
    $provide.value(
      'RecordedVoiceoversObjectFactory',
      new RecordedVoiceoversObjectFactory(new VoiceoverObjectFactory()));
    $provide.value('SkillRightsObjectFactory', new SkillRightsObjectFactory());
    $provide.value(
      'SubtitledHtmlObjectFactory', new SubtitledHtmlObjectFactory());
    $provide.value('VoiceoverObjectFactory', new VoiceoverObjectFactory());
    $provide.value(
      'EditableSkillBackendApiService',
      [fakeEditableSkillBackendApiService][0]);

    fakeSkillRightsBackendApiService = (
      FakeSkillRightsBackendApiService());
    $provide.value(
      'SkillRightsBackendApiService',
      [fakeSkillRightsBackendApiService][0]);
  }));
  beforeEach(angular.mock.module('oppia', function($provide) {
    var ugs = new UpgradedServices();
    for (let [key, value] of Object.entries(ugs.getUpgradedServices())) {
      $provide.value(key, value);
    }
  }));
  beforeEach(angular.mock.inject(function($injector) {
    skillEditorStateService = $injector.get(
      'SkillEditorStateService');
    skillObjectFactory=$injector.get('SkillObjectFactory')
      // The injector is required because this service is directly used in this
    // spec, therefore even though SkillRightsObjectFactory is upgraded to
    // Angular, it cannot be used just by instantiating it by its class but
    // instead needs to be injected. Note that 'skillRightsObjectFactory' is
    // the injected service instance whereas 'SkillRightsObjectFactory' is the
    // service class itself. Therefore, use the instance instead of the class in
    // the specs.
    skillRightsObjectFactory = $injector.get('SkillRightsObjectFactory');
    skillUpdateService = $injector.get('SkillUpdateService');
    skillDifficulties = $injector.get('SKILL_DIFFICULTIES');
    $q = $injector.get('$q');
    $rootScope = $injector.get('$rootScope');

    var misconceptionDict1 = {
      id: '2',
      name: 'test name',
      notes: 'test notes',
      feedback: 'test feedback',
      must_be_addressed: true
    };

    var misconceptionDict2 = {
      id: '4',
      name: 'test name',
      notes: 'test notes',
      feedback: 'test feedback',
      must_be_addressed: false
    };

    var rubricDict = {
      difficulty: skillDifficulties[0],
      explanation: 'explanation'
    };

    var skillContentsDict = {
      explanation: {
        html: 'test explanation',
        content_id: 'explanation',
      },
      worked_examples: [
        {
          html: 'worked example 1',
          content_id: 'worked_example_1'
        },
        {
          html: 'worked example 2',
          content_id: 'worked_example_2'
        }
      ],
      recorded_voiceovers: {
        voiceovers_mapping: {
          explanation: {},
          worked_example_1: {},
          worked_example_2: {}
        }
      }
    };

    var skillDict = {
      id: 'skill_id_1',
      description: 'test description',
      misconceptions: [misconceptionDict1, misconceptionDict2],
      rubrics: [rubricDict],
      skill_contents: skillContentsDict,
      language_code: 'en',
      version: 3,
      prerequisite_skill_ids: []
    };

    skillRightsObject = {
      skill_id: 'skill_id_1',
      can_edit_skill_description: true
    };
    fakeSkillRightsBackendApiService.backendSkillRightsObject = (
      skillRightsObject);

    fakeEditableSkillBackendApiService.newBackendSkillObject = skillDict;
  }));

  it('should request to load the skill from the backend', function() {
    spyOn(fakeEditableSkillBackendApiService, 'fetchSkill').and.callThrough();
    skillEditorStateService.loadSkill('skill_id_1');
    expect(fakeEditableSkillBackendApiService.fetchSkill)
      .toHaveBeenCalled();
  });

  it('should track whether it is currently loading the skill', function() {
    expect(skillEditorStateService.isLoadingSkill()).toBe(false);
    skillEditorStateService.loadSkill('skill_id_1');
    expect(skillEditorStateService.isLoadingSkill()).toBe(true);
    $rootScope.$apply();
    expect(skillEditorStateService.isLoadingSkill()).toBe(false);
  });
  it('should indicate a collection is no longer loading after an error',
    function() {
      spyOn(fakeEditableSkillBackendApiService, 'fetchSkill').and.callThrough();
      expect(skillEditorStateService.isLoadingSkill()).toBe(false);
      fakeEditableSkillBackendApiService.failure = 'Internal 500 error';
      skillEditorStateService.loadSkill('skill_id_1');
      expect(skillEditorStateService.isLoadingSkill()).toBe(true);
      $rootScope.$apply();
      expect(skillEditorStateService.isLoadingSkill()).toBe(false);
    });
  //error
  it('should report that a skill has loaded through loadSkill()', function() {
    expect(skillEditorStateService.hasLoadedSkill()).toBe(false);
    var newSkill = skillEditorStateService.loadSkill('skill_id_1');
    expect(skillEditorStateService.hasLoadedSkill()).toBe(true);
    $rootScope.$apply();
    expect(skillEditorStateService.hasLoadedSkill()).toBe(true);
    var groupedSkillSummaries =
      skillEditorStateService.getGroupedSkillSummaries();
    expect(groupedSkillSummaries.current.length).toEqual(2);
    expect(groupedSkillSummaries.others.length).toEqual(0);

    expect(groupedSkillSummaries.current[0].id).toEqual('skill_id_1');
    expect(groupedSkillSummaries.current[1].id).toEqual('skill_id_2');
  });
  //error
  it('should return the last skill loaded as the same object', function() {
    spyOn(fakeEditableSkillBackendApiService, 'fetchSkill').and.callThrough();
    var previousSkill = skillEditorStateService.getSkill();
    var expectedSkill = skillObjectFactory.createFromBackendDict(
      fakeEditableSkillBackendApiService.newBackendSkillObject);
    expect(previousSkill).not.toEqual(expectedSkill);
    skillEditorStateService.loadSkill('skill_id_1');
    $rootScope.$apply();
    var actualSkill = skillEditorStateService.getSkill();
    expect(actualSkill).toEqual(expectedSkill);
    expect(actualSkill).toBe(previousSkill);
    expect(actualSkill).not.toBe(expectedSkill);
  });

  it('should fail to load a skill without first loading one',
    function() {
      expect(function() {
        skillEditorStateService.saveSkill('commit message');
      }).toThrow();
    });

  it('should not save the skill if there are no pending changes',
    function() {
      skillEditorStateService.loadSkill('skill_id_1');
      $rootScope.$apply();
      expect(skillEditorStateService.saveSkill(
        'commit message')).toBe(false);
    });
  //error
  it('should be able to save the collection and pending changes',
    function() {
      spyOn(fakeEditableSkillBackendApiService,
        'updateSkill').and.callThrough();

      skillEditorStateService.loadSkill('skill_id_1');
      expect('1').toBe(skillEditorStateService.getSkill())
      skillUpdateService.setSkillDescription(
        skillEditorStateService.getSkill(), 'new description');
      $rootScope.$apply();

      expect(skillEditorStateService.saveSkill(
        'commit message')).toBe(true);
      $rootScope.$apply();

      var expectedId = 'skill_id_1';
      var expectedVersion = 3;
      var expectedCommitMessage = 'commit message';
      var updateSkillSpy = (
        fakeEditableSkillBackendApiService.updateSkill);
      expect(updateSkillSpy).toHaveBeenCalledWith(
        expectedId, expectedVersion, expectedCommitMessage,
        jasmine.any(Object));
    });
  //error
  it('should track whether it is currently saving the skill',
    function() {
      spyOn(fakeEditableSkillBackendApiService,
        'updateSkill').and.callThrough();
      skillEditorStateService.loadSkill('skill_id_1');
      skillUpdateService.setSkillDescription(
        skillEditorStateService.getSkill(), 'new description');
      $rootScope.$apply();
      expect(skillEditorStateService.isSavingSkill()).toBe(false);
      skillEditorStateService.saveSkill('commit message');
      expect(skillEditorStateService.isSavingSkill()).toBe(true);

      $rootScope.$apply();
      expect(skillEditorStateService.isSavingSkill()).toBe(false);
    });

  it('should indicate a skill is no longer saving after an error',
    function() {
      skillEditorStateService.loadSkill('skill_id_1');
      skillUpdateService.setSkillDescription(
        skillEditorStateService.getSkill(), 'new description');
      $rootScope.$apply();

      expect(skillEditorStateService.isSavingSkill()).toBe(false);
      fakeEditableSkillBackendApiService.failure = 'Internal 500 error';

      skillEditorStateService.saveSkill('commit message');
      expect(skillEditorStateService.isSavingSkill()).toBe(true);

      $rootScope.$apply();
      expect(skillEditorStateService.isSavingSkill()).toBe(false);
    });

  it('should request to load the skill rights from the backend',
    function() {
      spyOn(fakeSkillRightsBackendApiService, 'fetchSkillRights')
        .and.callThrough();

      skillEditorStateService.loadSkill('skill_id_1');
      expect(fakeSkillRightsBackendApiService.fetchSkillRights)
        .toHaveBeenCalled();
    });

  it('should initially return an interstitial skill rights object', function() {
    var skillRights = skillEditorStateService.getSkillRights();
    expect(skillRights.getSkillId()).toEqual(null);
    expect(skillRights.canEditSkillDescription()).toEqual(false);
  });

  it('should be able to set a new skill rights with an in-place copy',
    function() {
      var previousSkillRights = skillEditorStateService.getSkillRights();
      var expectedSkillRights = skillRightsObjectFactory.createFromBackendDict(
        skillRightsObject);
      expect(previousSkillRights).not.toEqual(expectedSkillRights);

      skillEditorStateService.setSkillRights(expectedSkillRights);

      var actualSkillRights = skillEditorStateService.getSkillRights();
      expect(actualSkillRights).toEqual(expectedSkillRights);

      expect(actualSkillRights).toBe(previousSkillRights);
      expect(actualSkillRights).not.toBe(expectedSkillRights);
    }
  );
});